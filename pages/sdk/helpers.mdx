# Helpers

## networkChainMatches

> Requires either `signer` or `provider`

Helper to validate the network of the client signer or provider

```ts
// boolean
const isConnectedToMainnet = await client.networkChainMatches({
  chainId: 1,
})
```

## isSoundEdition

> Requires either `signer` or `provider`

Quickly check if given address is a supported contract

```ts
// true | false
const isAddressSoundEdition = await client.isSoundEdition({
  editionAddress: '0x...',
})
```

## getContractError

> Requires either `provider` or `signer` with indirect provider

Attempt to get the kind of error associated with failed transaction based on a set of known signature hashes.

It returns `null` if it doesn't find a match

```ts
const failedTx = '...'

// ...

/**
 * 'MetadataIsFrozen' | 
  'InvalidRoyaltyBPS' | 
  'InvalidRandomnessLock' | 
  'ExceedsEditionAvailableSupply' | 
  'InvalidAmount' | 
  'InvalidFundingRecipient' | 
  'InvalidEditionMaxMintableRange' | 
  'MaximumHasAlreadyBeenReached' | 
  'ExceedsAddressBatchMintLimit' | 
  'MintRandomnessAlreadyRevealed' | 
  'NoAddressesToAirdrop' | 
  'MintHasConcluded' | 
  'MintsAlreadyExist' | 
  'Underpaid' | 
  'ExceedsAvailableSupply' | 
  'MintNotOpen' | 
  'MintPaused' | 
  'InvalidTimeRange' | 
  'Unauthorized' | 
  'InvalidAffiliateFeeBPS' | 
  'FeeRegistryIsZeroAddress' | 
  'InvalidMaxMintableRange' | 
  'ExceedsMaxPerAccount' | 
  'MaxMintablePerAccountIsZero' | 
  'InvalidMerkleProof' | 
  'MerkleRootHashIsEmpty' |
  null
 */
const errorName = await client.getContractError(failedTx)
```
